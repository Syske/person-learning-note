## 关于MYSQL你该知道的

## 前言

目前很多大厂的数据库都用的是`MySQL`，为了更好地适应面试，同时也为了入职后能更好适应工作，那么了解一些`mysql`的知识点就显得特别重要，今天我们就来看下`mysql`的一些知识，今天主要介绍两块知识点，一个是有关数据库索引的，一个是关于数据库存储引擎，好了，直接开始今天的内容。



## 正文

### 什么是索引

- 聚焦索引（存储连续，类似目录，1后面肯定是2）

- 非聚集索引（存储不连续，例如包含“弓”的汉字）

聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个；索引顺序和数据库表的排列顺序是不一样的，这个样的就是非聚集索引

### 建立索引的原则

1) 定义主键的数据列一定要建立索引。

2) 定义有外键的数据列一定要建立索引。

3) 对于经常查询的数据列最好建立索引。

4) 对于需要在指定范围内的快速或频繁查询的数据列;

5) 经常用在WHERE子句中的数据列。

6) 经常出现在关键字order by、group by、distinct后面的字段，建立索引。如果建立的是复合索引，索引的字段顺序要和这些关键字后面的字段顺序一致，否则索引不会被使用。

7) 对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。

8) 对于定义为text、image和bit的数据类型的列不要建立索引。

9) 对于经常存取的列避免建立索引 

10) 限制表上的索引数目。对一个存在大量更新操作的表，所建索引的数目一般不要超过3个，最多不要超过5个。索引虽说提高了访问速度，但太多索引会影响数据的更新操作。

11) 对复合索引，按照字段在查询条件中出现的频度建立索引。在复合索引中，记录首先按照第一个字段排序。对于在第一个字段上取值相同的记录，系统再按照第二个字段的取值排序，以此类推。因此只有复合索引的第一个字段出现在查询条件中，该索引才可能被使用,因此将应用频度高的字段，放置在复合索引的前面，会使系统最大可能地使用此索引，发挥索引的作用。

### 索引方式

- `BTREE`：btree是多路平衡搜索树，和avl相比它不是二叉的，而是多叉的，有很多个分支，M阶的btree就是树的度是M，最多有M个分支。
- `HASH`：Hash索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以Hash索引的查询效率要远高于B-Tree索引

**两种索引方式的区别**：

1. `Hash`索引仅仅能满足"`=`","`IN`"和"`<=>`"查询，不能使用范围查询。哈希索引只支持等值比较查询，包括`＝`、 `IN` 、`<=>` (注意`<>`和`＜＝＞`是不同的操作）。也不支持任何范围查询，例如`WHERE price > 100`。　　
   由于`Hash`索引比较的是进行`Hash`运算之后的`Hash`值，所以它只能用于等值的过滤，不能用于基于范围的过滤，**因为经过相应的`Hash`算法处理之后的`Hash`值的大小关系，并不能保证和`Hash`运算前完全一样。**
2. `Has`h索引无法被用来避免数据的排序操作。　　
   由于`Hash`索引中存放的是经过`Hash`计算之后的`Hash`值，**而且`Hash`值的大小关系并不一定和`Hash`运算前的键值完全一样**，所以数据库无法利用索引的数据来避免任何排序运算;
3. `Hash`索引不能利用部分索引键查询。　　
   对于组合索引，**`Hash`索引在计算`Hash`值的时候是组合索引键合并后再一起计算`Hash`值，而不是单独计算`Hash`值**，所以通过组合索引的前面一个或几个索引键进行查询的时候，`Hash`索引也无法被利用。
4. `Hash`索引在任何时候都不能避免表扫描。　　
   前面已经知道，**`Hash`索引是将索引键通过`Hash`运算之后，将`Hash`运算结果的`Hash`值和所对应的行指针信息存放于一个`Hash`表中**，由于不同索引键存在相同`Hash`值，所以即使取满足某个`Hash`键值的数据的记录条数，也无法从`Hash`索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。
5. **`Hash`索引遇到大量`Hash`值相等的情况后性能并不一定就会比`BTree`索引高**。　
   对于选择性比较低的索引键，如果创建`Hash`索引，那么将会存在大量记录指针信息存于同一个`Hash`值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下。

### mysql常用的存储引擎

#### InnoDB

`mysql`的默认引擎(5.5版之后)，支持事务，支持行级锁和外键约束，提供了对数据库`ACID`(原子性、一致性、独立性、持久性)事务的支持，并且实现了`SQL`标准的四种隔离级别，它的设计目的是处理大容量数据库系统，`MYSQL`运行时`InnoDB`会在内存中建立缓存池，用于缓存数据和索引。

当需要使用数据库事务时，该引擎是首选，由于锁的粒度小，写操作不会锁定全表，所以在并发较高时，使用`InnoDB`会提升效率。但使用行级锁也不是绝对的，如果执行一个`SQL`语句时，`MYSQL`不能确定要扫描的范围，`InnoDB`同样会锁全表。

**适用的场景：**

1. 经常更新的表，适合处理多重并发的更新请求
2. 需要支持事务
3. 可以从灾难中恢复（通过`bin-log`日志等）
4. 需要支持外键约束，只有`InnoDB`支持外键
5. 需要支持自动增加列属性`auto_increment`

**优点：**

1、提供事物支持。

2、提供系统崩溃修复能力。

3、支持多版本并发控制（即`MVCC Multi-Version Concurrency Control`）的行级锁，由于锁粒度小，写操作和更新操作并发高、速度快。适合更新频繁的表。

4、支持自增长列。

5、支持外键。

6、适合于大容量数据库系统，支持自动灾难恢复。

#### CSV

使用该引擎的`MySQL`数据库表会在`MySQL`安装目录`data`文件夹中与该表所在数据库名相同的目录中生成一个`.CSV`文件（所以，它可以将`CSV`类型的文件当做表进行处理），这种文件是一种普通文本文件，每个数据行占用一个文本行。该种类型的存储引擎不支持索引，即使用该种类型的表没有主键列；另外也不允许表中的字段为`null`。

#### ARCHIVE

`ARCHIVE`存储引擎非常适合存储大量独立的、作为历史记录的数据。区别于`InnoDB`和`MyISAM`这两种引擎，`ARCHIVE`提供了压缩功能，拥有高效的插入速度，但是这种引擎不支持索引，所以查询性能较差一些。

#### BLACKHOLE

`Blackhole`（黑洞引擎）任何写入到此引擎的数据均会被丢弃掉，不做实际存储；`Select`语句的内容永远是空。

他会丢弃所有的插入的数据，服务器会记录下`Blackhole`表的日志，所以可以用于复制数据到备份数据库。

**使用场景：**

1）验证`dump file`语法的正确性

2）以使用`blackhole`引擎来检测`binlog`功能所需要的额外负载

3）充当日志服务器



#### MEMORY

为了得到最快的响应时间，`MEMORY`引擎采用的逻辑存储介质是系统内存。

**优点：**

1. 在内存中存储表数据具有很高的性能。

2. 同时支持散列索引和B树索引。

**缺点：**

1. `MySQL`守护进程崩溃时，所有`memory`数据都会丢失。

2. 不能使用长度可变的数据类型（如`BLOB`和`TEXT`）,但`varchar`类型可用（`varchar`在`MySQL`内部被当做`char`类型）

以下几种情况适合使用`Memory`引擎：

1、目标数据较小，且被频繁访问。

2、表数据是临时的、且要求立即使用

3、`Memory`表数据丢、不会对应用服务产生实质影响

注：B树索引的优于散列索引的是，可以使用部分查询和通配查询，也可以使用`<`、`>`和`>=`等操作符方便数据挖掘。散列索引进行“相等比较”非常快，但是对“范围比较”的速度就慢多了，因此散列索引值适合使用在`=`和`<>`的操作符中，不适合在`<`或`>`操作符中，也同样不适合用在`order by`子句中。

#### MRG_MYISAM

（分表的一种方式–水平分表）是一个相同的可以被当作一个来用的`MyISAM`表的集合。“相同”意味着所有表同样的列和索引信息。

也就是说，他将`MyIsam`引擎的多个表聚合起来，但是他的内部没有数据，真正的数据依然是`MyIsam`引擎的表中，但是可以直接进行查询、删除更新等操作。

比如：我们可能会遇到这样的问题，同一种类的数据会根据数据的时间分为多个表，如果这时候进行查询的话，就会比较麻烦，`Merge`可以直接将多个表聚合成一个表统一查询，然后再删除`Merge`表（删除的是定义），原来的数据不会影响。

存储是基于 MyISAM的引擎的表， 对于业务可以拆分，多读多写，少更新的场景， 可以采用MRG_MyISAM实现数据库的简单分片。

但是基于MRG_MyISAM的存储会有如下问题

1. 未指明 实际存储表的大查询， 会有更多的merge操作，并且不走索引， 建议使用union all 代替

2. 多表引起的 id 一致问题， 自增主键引起冲突
#### MYISAM

`MyIASM`是`MySQL`默认的引擎，使用一种表格锁定的机制来优化多个并发的读写操作。需要经常运行`OPTIMIZE TABLE`命令，来恢复被更新机制所浪费的空间，否则碎片也会随之增加，最终影响数据访问性能。  

**优点：**

1、`MyISAM`表是独立于操作系统的，这说明可以轻松地将其从`Windows`服务器移植到`Linux`服务器。

2、`MyISAM`存储引擎在查询大量数据时非常迅速，这是它最突出的优点。

3、另外进行大批量插入操作时执行速度也比较快。

4、单独保存了表的行数。

**缺点：**

1、`MyISAM`表没有提供对数据库事务的支持。

2、不支持行级锁和外键。

3、不适合用于经常`UPDATE`（更新）的表，效率低。

#### PERFORMANCE_SCHEMA

该引擎主要用于收集数据库服务器性能参数。这种引擎提供以下功能：提供进程等待的详细信息，包括锁、互斥变量、文件信息；保存历史的事件汇总信息，为提供`MySQL`服务器性能做出详细的判断；对于新增和删除监控事件点都非常容易，并可以随意改变`mysql`服务器的监控周期，例如（`CYCLE`、`MICROSECOND`）。



#### 使用建议

以下两点必须使用 InnoDB：

1）可靠性高或者要求事务处理，则使用InnoDB。这个是必须的。

2）表更新和查询都相当的频繁，并且表锁定的机会比较大的情况指定InnoDB数据引擎的创建。

对比之下，MyISAM的使用场景：

1）做很多count的计算的。如一些日志，调查的业务表。

2）插入修改不频繁，查询非常频繁的。



## 结语

好了，今天的内容就到这里，在最后分享一个`mysql`的面试题，小伙伴可以好好思考下：

`varchar`和`char`有什么区别？如果分别定义了`varchar(10)`和`char(10)`两个字段，让他们保存`10`个汉字，会发生什么？