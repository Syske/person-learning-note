# RocketMQ基本概念

### 前言

现在我学习新技术的路径基本是：`quick start`  -> 简单应用 -> 踩坑，查资料 -> 积累经验，后知后觉

为了改变这种被动的踩坑式学习，这一次我决定先学习`RocketMQ`的基本概念和它的设计模式，毕竟清楚了游戏规则，才能确保我们在游戏中获胜，否则会浪费很多时间。



### 基本概念



#### 消息模型

- `producer`：消息生产者
- `Consumer`：消息消费者
- `Broker`：存储消息

在`RocketMQ`的官方文档中，这一块也说得很清楚：

> `RocketMQ`主要由 `Producer`、`Broker`、`Consumer `三部分组成，其中`Producer `负责生产消息，`Consumer `负责消费消息，`Broker `负责存储消息。
>
> `Broker `在实际部署过程中对应一台服务器，每个 `Broker `可以存储多个Topic的消息，每个`Topic`的消息也可以分片存储于不同的 `Broker`。
>
> `Message Queue` 用于存储消息的物理地址，每个`Topic`中的消息地址存储于多个 `Message Queue` 中。`ConsumerGroup `由多个`Consumer `实例构成。

##### 生产者（Producer）

生产消息，负责将业务系统中的消息发送到`broker`服务器中，支持多种消息发送方式：

- 同步发送（需要`broker`返回确认信息）
- 异步发送（需要`broker`返回确认信息）
- 顺序发送
- 单向发送



##### 消费者（Consumer）

消费消息，异步消费。消费者从`broker`服务器拉取消息，然后进行消费，消费方式有两种：

- 拉取式消费
- 推动式消费



##### 代理服务器（broker）

负责消息存储，接收生产者发送的消息并存储，同时为消费者消费消息做准备。`broker`也存储消息相关的元数据，包括：

- 消费者组
- 消费进度偏移
- 主题
- 队列消息



#### 名称服务（namesrv）

名称服务充当路由消息的提供者，生产者或消费者可以通过名称服务查找各主题对应的`broker`服务`IP`列表。多个`namesrv`实例组成集群，但互相独立，没有信息交换。



#### 消息相关概念

##### 主题（topic）

一类消息的集合，每个主题包含多条消息，每条消息只能属于一个主题，它是`RocketMQ`进行消息订阅的最小（基本）单位。



##### 标签（tag）

为消息设置的标志，用于同一主题下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化`RocketMQ`提供的查询系统。消费者可以根据`Tag`实现对不同子主题的不同消费逻辑，实现更好的扩展性。

##### 消息（message）

消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。`RocketMQ`中每个消息拥有唯一的`Message ID`，且可以携带具有业务标识的`Key`。系统提供了通过`Message ID`和`Key`查询消息的功能。

- 普通顺序消息：普通顺序消费模式下，消费者通过同一个消息队列（ `Topic `分区，称作 `Message Queue`） 收到的消息是有顺序的，不同消息队列收到的消息则可能是无顺序的。
- 严格顺序消息：严格顺序消息模式下，消费者收到的所有消息均是有顺序的。



#### 组概念

##### 生产者组

同一类`Producer`的集合，这类`Producer`发送同一类消息且发送逻辑一致。如果发送的是事务消息且原始生产者在发送之后崩溃，则`Broker`服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。

##### 消费者组

同一类`Consumer`的集合，这类`Consumer`通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。要注意的是，消费者组的消费者实例必须订阅完全相同的`Topic`。`RocketMQ `支持两种消息模式：集群消费（`Clustering`）和广播消费（`Broadcasting`）。

#### 消费方式

##### 集群消费

集群消费模式下，相同`Consumer Group`的每个`Consumer`实例平均分摊消息。

##### 广播消费

广播消费模式下，相同`Consumer Group`的每个`Consumer`实例都接收全量的消息。

##### 拉取式消费

`Consumer`消费的一种类型，应用通常主动调用`Consumer`的拉消息方法从`Broker`服务器拉消息、主动权由应用控制。一旦获取了批量消息，应用就会启动消费过程。

##### 推动式消费

`Consumer`消费的一种类型，该模式下`Broker`收到数据后会主动推送给消费端，该消费模式一般实时性较高。



