## 背景
首先是业务背景，公司的项目基本都是基于`sofa-boot`的微服务架构（支付宝开源的基于`springboot`的`rpc`版本），用到很多中间件，比如有`MQ`、`sofa-rpc`、线程池等，日常发版时虽然已经尽可能在业务低峰期进行，但是发版过程中还是会由于组件没有正常关闭而导致现网用户数据异常，于是基于这个业务背景，我们上个月专门做了服务优雅关机的优化升级。

技术层面，由于我们使用的`sofa-boot`的版本比较低（`3.22`，依赖的`spring-boot`版本是`2.1.0`），官方很多组件并不支持优雅关机，盲目升级组件的版本会引入很多未知的风险，而且测试工作量也是惊人的，加之官方的优雅关机并不支持自定义各个组件优雅关机的优先级，灵活性比较差，于是手写自己的`springb-boot-starter`就成了最好的选择。

下面就让我们来一起回顾下，如何自定义自己的`spring-boot`优雅关机组件，实现更灵活的优雅关机。我们先来看下`k8s`节点的关机流程：

## k8s节点关机流程概要

首先，要提一个技术背景，我们的服务都是基于`k8s`部署的，所有我们本次的技术实现要考虑`k8s`环境的特殊性。我们先来看下`k8s`下`pod`的关机时序图：
![k8s pod关机流程](https://syske-pic-bed.oss-cn-hangzhou.aliyuncs.com/imgs/98951966-cef9-4a57-9de6-f8735fde5ae5.jpg)
这里我也放出`docker`容器和传统`linux`环境`springboot`关机时序图，方便大家对比：
![docker容器关闭流程](https://syske-pic-bed.oss-cn-hangzhou.aliyuncs.com/imgs/9d99e299-a05f-48ab-a055-1f69895e45a4.jpg)传统`linux`环境，`springboot`的关闭流程：
![linux环境springboot关机流程](https://syske-pic-bed.oss-cn-hangzhou.aliyuncs.com/imgs/03f637ec-2ed0-430c-b01b-c78ce989fd69.jpg)


我们简单总结下`k8s pod`的启动流程，这里有几个关键的点，也是我们实现优雅关机的核心：
### 发送`SIGTERM`信号到`pod`

`SIGTERM`信号的监听和处理，通常都需要程序自行处理，所以我们本次方案的触发也是基于`SIGTERM`的监听和处理。当然，不论是传统的`linux`还是`docker`环境，我们所有的优雅关机在这一点上其实都是类似的。

我是直到写这篇文章的时候才发现，这里的`SIGTERM`实际就是`kill -15`中的`15`对应的信号量（功课做的不够啊🤦‍）。这也是为什么之前在`linux`环境中，推荐的都是直接`kill`（默认的信号就是`15`）或者`kill -15`，而不是`kill -9`，`9`对应的信号是`SIGKILL`，也就是强制关闭。

### 发送`SIGKILL`强制终止

这里实际上是优雅关机的终点，也就是我们的应用必须在此之前完成优雅关机，否则会被强制杀死。这一点在`docker`中也有，其实就是系统的兜底操作，即在应用关机超时时，强制将应用杀死，确保`pod`能正常关闭。但是传统`linux`只能我们手动触发`SIGKILL`信号。

### 最大宽限期

这一点是`k8s`比较特殊的点，最大宽限期（`terminationGracePeriodSeconds`），这个时间默认时间是`30`秒，计算逻辑如下：
```
`pod`内`preStop`钩子的运行时间 + 服务优雅关机的时间
```

这个时间的计时开始是从`pod`节点被标记为`Terminating`开始的，从最上面的时序图我们可以看到，`preStop`的执行流程是包含在最大宽限期内的：
![](https://syske-pic-bed.oss-cn-hangzhou.aliyuncs.com/imgs/25979c5d-0375-401f-998b-e11248598cfc.jpg)
也就是如果`preStop`运行过久，会导致应用无法优雅关机，所以我们需要合理设置最大宽限期和`preStop`的设置，我们现网服务并没有设置这个钩子。这里给出`preStop`的设置入口截图，它位于容器的生命周期设置下：
![](https://syske-pic-bed.oss-cn-hangzhou.aliyuncs.com/imgs/04a0a21f-b64a-458d-8e15-cf355d22af29.jpg)
如果不设置`preStop`，最大宽限期就等于优雅关机能够执行的最大时间。

## 小结

今天我们简单介绍了`k8s`节点关机的流程，分享了基于`k8s`的`spring boot`应用的关机要点和核心概念，让大家对`k8s`节点的关闭流程有了基本的认识，为后续我们分享`k8s`环境下`springboot`优雅关机做一个简单的铺垫。当然，这也是我针对本项目的总结和梳理，后面也要基于这些内容，给团队内的小伙伴做分享，今天让大家先尝个鲜。

这里也预告下后面的内容，预计下次分享可以把`k8s`环境下`springboot`应用优雅关机的内容分享完，不过具体得看情况，主要包含如下内容：
- `SIGTERM`信号的监听和处理
- 预关机实现：收到`SIGTERM`后，按设置的顺序，串行完成组件优雅关机
- 各个中间件的优雅关机：`Tomcat`、`sofa-rpc`、`ActiveMQ`、`RocketMQ`、线程池
- 各个中间件的监控：主要是收集活跃的线程、消息、请求等，为优雅关机提供数据支持

好了，今天的内容就到这里吧，各位小伙伴周末快乐呀！