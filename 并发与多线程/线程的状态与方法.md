# 线程的状态与方法

### 前言

今天我们来探讨下线程的状态和方法，关于线程状态我们会围绕线程的运行流程来分析，方法这块我会尽可能分析线程（`Thread`）的每一个方法，由于`Runnable`和`Callable`有且仅有一个`run`方法，所以我们今天讨论的重点是`Thread`类，好了，下面让我们详细来看下吧。

### 线程的状态和方法

#### 线程的状态

首先是线程的状态，一个线程会有如下几种状态：

- `NEW`：新建状态，线程实例化完成后尚未运行时处于该状态下（`Thread state for a thread which has not yet started.`）

  ![](https://gitee.com/sysker/picBed/raw/master/blog/20211110084839.png)

- `RUNABLE`：可运行状态，在这种状态下，限制在`jvm`正在运行，但是不一定正在运行，它可能在等操作系统的某个资源，比如处理器资源

- `BLOCKED`：阻塞状态，在这种状态下，说明线程正在等一个受监控的锁，拿到这个锁，他就可以进入到`synchronized`的代码块或者方法中开始运行，或者在调用`Object.wait`后重新进入`synchronized`的代码块或者方法中开始运行。

- `WAITING`：等待状态，线程处于等待状态是由于调用`Objecet.wait`、`Thread.join`或者`LockSupport.part`方法中的任意一个导致的，处于等待状态的线程必须等待其他线程完成特定操作才能恢复，例如，一个线程调用了一个对象的`Object.wait()`方法，它必须等待其他线程调用` Object.notify()`或者`Object.notifyAll()`才能恢复.。调用了`Thread.join()`的线程，必须等待其他线程执行完成。

- `TIMED_WAITING`：有时间限制的等待状态，当然从名字上我们也能看出来，这是一种有超时时间的等待状态，达到等待时长时会自动恢复，一个线程进入这种状态，通常是调用了如下方法：`Thread.sleep`、带超时时间的`Object.wait`、带超时时间的`Thread.join`、`LockSupport.parkNanos`、`LockSupport.parkUntil`

- `TERMINATED`：结束状态，线程运行完成后的状态。



#### 线程的方法



### 结语

