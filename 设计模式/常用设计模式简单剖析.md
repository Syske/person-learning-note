# 常用设计模式简单剖析

### 前言

在上个月的推送内容中，我们先是简单剖析了`spring boot`的源码，然后在节前快放假的时候，我们简单剖析了`Tomcat`启动过程的源码，从这一些的源码剖析过程中，我发现虽然他们的源码我都可以看懂，流程可以可以梳理清楚，但是每次基本上都是在所有源码梳理清楚之后才能理清楚其中的执行流程以及作用，这就让我很被动，而且很浪费时间。

然后在看了一些大佬剖析源码的内容以后，我发现自己真正欠缺的是设计模式的相关知识，正是由于这些知识的欠缺才导致我在看源码的时候，效率如此低下。

这一点也很好理解，设计模式其实就类似于我们建房子的图纸，有了设计模式的加持，可以让我们看清源码的设计架构，甚至可以让我们推断出它的实现原理。所以，我决定暂时先放下`Tomcat`源码的剖析，待补充完设计模式相关知识点之后，我们再继续前行。

### 常用设计模式

不论是在`java`的源码实现中，还是在`java`的常用框架中（比如`spring`等），设计模式都被广泛的应用，但是由于它是更偏向设计层面的内容，所以我们在学习`java`的时候，会经常忽略它我们绝大多数人（包括我）对它都置若罔闻，在写代码的时候也根本不会想到他，以至于我们写出的代码扩展性和健壮性极差，而且效率低下。

为了能够纠正这种不好的习惯，提升我们的编码软实力，从今天起我们开始剖析`java`的常用设计模式，同时会在平时相关内容分享的时候，尽可能多踢他，以便让我们真正意识到它的存在，当然，同时也为了让我们写出更优秀的代码。

常用的设计模式有以下几种：

- 单例模式：确保有且只有一个对象被创建
- 工厂方法模式：由子类决定要创建的具体类是哪一个
- 抽象工厂模式：允许客户创建对象的家族，而无需指定他们的具体类
- 观察者模式：让对象能够在状态改变时被通知
- 装饰者模式：包装一个对象，以提供新的行为
- 策略模式：封装可以互换的行为，并使用委托来决定要使用哪一个
- 命令模式：封装请求成为对象
- 适配器模式：封装对象，并提供不不同的接口
- 外观模式：简化一群类的接口
- 模板方法模式：由子类决定如何实现一个算法中的步骤
- 迭代器模式：在对象的集合之中游走，而不暴露集合的实现
- 组合模式：客户用一致的方式处理对象集合和单个对象
- 代理模式：包装对象，以控制对此对象的访问
- 状态模式：封装了基于状态的行为，并使用委托在行为之间切换
- 复合模式：多个设计模式组合使用

除了上面这些设计模式外，还有一些其他的设计模式：

- 桥接
- 生成器
- 责任链
- 蝇量
- 解释器
- 中介者
- 备忘录
- 原型
- 访问者





### 总结

各位小伙伴，十一假期过得可好？反正，我的整体体验很差，好好的七天小长假，下了整整一周雨，所以每天不是在下雨，就是在下雨的路上，出去玩了三天，出了出发的第一天，后面基本上天天下雨，又冷又累😑，我寻思啥时候大西北变成大江南了，竟如此的阴雨连绵……



